using System;

namespace Memous
{
    class Program
    {
        static void Main(string[] args)
        {
            //Когато търсим нещо винаги имаме worst case, average case and best case(например при търсене в масив винаги изхождаме от worst case (търсения елемент може да е последния). 

            //"The Stack" е малка фиксирана част от РАМ паметта - 1 MB (32 bit operating system) или 2 MB ( 64-bit operating system)

            // reg Tab Tab ни отваря регион в който можем да си запишем код, мемо или съмъри и да му дадем име!
            #region propful
            //propful + Tab Tab ще ни разпъне автоматично fild с конструктор и ще ни предпази от евентуална рекурсия при грешка в get-ера (да дава с главна буква)
            #endregion

            //A star search algurithm - за намиране на най - кратък път (Гугъл мапс го ползва)
            //Dijkstra algurithm - за намиране на най - кратък път
            //но са сложни (за курса по алгуритми са)

            //!!!Един алгуритъм дори и много пъти да сме използвали, винаги е добре преди да го разпишем да си погледнем в нета как беше (псевдо код, върши ни обикновенно много добра работа и много често от Wikipedia го ползва Виктор)!!!

            //видеото за рекурсията в Ютуб като напишем Виктор Даков ще излезне !!!

            //Обикновенно гриди алг. са по ефективни от брут форс, но имат и проблеми!(могат да правят не оптимални резултати)

            //Пермутация е например да разместим елементите на дадена колекция.

            //Предпочитани са алгуритмите, които изискват по - малко операции, те са по-бързи!

            //Най - якото сортиране e StalinSort - вървим напред в колекцията и който елемент не ни върши работа го премахваме!

            //Най-известни сортиращи алг -ми: insertion, exchange(buble sort and quicksort), selection(heapsort - много як), merging. 

            //stability - stable/unstable - Едеин алгуритъм е стабилен, когато на еднаквите елементи  се запазва реда, нестабилен когато не се запазва. 
            //селекшън сорт разменя първия елемент с най-малкия и така се движи линейно по елементите на колекцията!
            //Bubble sort - ако имаме 10 елемента ни трябват 100 операции да сортираме, това е много, бавно е(броя на елементите на квадрат) - разменя два съседни елемента докато е необходимо(минава по дължината на колекцията многократно)!
            //Mergеsort and Quicksort са по-сложни и интересни!!!

            //Search algurithm - thipicaly answers true or false and index sometimes. Linear search. 

            //Binary search търси в сортирана колекция и е много бърз и ефективен!!!Complexity log n(логаритам от броя на елементите в колекцията!!!, така за един милион елемента получаваме 7 операции!?, а не 30)(намира в един милион елемента с грубо 30 операции каза Виктор, но опитно бяха 18-20). Binary search може да се направи итеративно, но най-лесно е рекурсивно! На база на това което виждаме колко е бързо, работи половината програмиране на този свят (базите данни така работят - там са сортирани дървета, но принципа е същия)!

            //Quicksort е най-използвания алгуритъм за сортировки!!! На теория Mergеsort e най-бърз, но на практика е Quicksort!
            //Quicksort се представя много зле при вече сортиран масив и зле подбран пивот, докато Mergеsort се представя  еднакво при всички случаи. 

            //Пишем Array. и имаме на разположение готов BinarySearch (добър и оптимизиран)

            //Рекурсия:
            //При функционалните езици циклите са рекурсия!

            //Рекурсията не винаги е много подходяща (при намиране на фибоначи не е!). Тя е подходяща когато имаме да изразходим (проверим) всички възможни случаи и не знаем колко са те (перфектна за намиране на пътища в лабиринт, за генериране на всички варианти, за изкуствен интелект(MinMaks е рекурсивен алгуритъм и се използва при компютърния шах - изчерпва всички възможни варианти, това прави рекурсията))

            //Depth first search- е първия алгуритъм с лабиринта от видеото за рекурсия : https://www.youtube.com/watch?v=KIKbqh7UEos&ab_channel=ViktorDakov (да си го разцъкам)
            //BFS - алгуритъм за нмиране на най-кратък път
            //Dijstra - за намиране на най - кратък пър в графа
            //EightQueen - е втория - типичен пример какво е брут форс, какво е бавно, какво е да имаме решения с множество вариации

            //!!!!!Препоръчани ресурси за рекурсия : в GeeksForGeeks : Divaide and Conquer, Backtracking, много са полезни!!!
            //https://visualgo.net/en/sorting за визуализация на алгуритми!
        }
    }
}
